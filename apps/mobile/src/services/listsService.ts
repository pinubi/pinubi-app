import { auth, firestore, functions } from '@/config/firebase';
import { firebaseService } from '@/services/firebaseService';
import type {
  AddPlaceToListRequest,
  CreateListRequest,
  GetListPlacesResponse,
  GetUserListsResponse,
  List,
  ListError,
  ListPlace,
  ListPlaceWithDetails,
  UpdateListRequest,
} from '@pinubi/types';
import {
  addDoc,
  arrayUnion,
  collection,
  deleteDoc,
  doc,
  getDoc,
  getDocs,
  increment,
  limit,
  orderBy,
  query,
  serverTimestamp,
  setDoc,
  updateDoc,
  where,
} from 'firebase/firestore';
import { httpsCallable } from 'firebase/functions';

class ListsService {
  private functions;

  constructor() {
    this.functions = functions;
  }

  /**
   * Generate mock data for testing
   */
  private generateMockLists(userId: string): List[] {
    return [
      {
        id: 'auto-want-to-visit',
        title: 'QUERO VISITAR',
        emoji: 'üçΩÔ∏è',
        description: 'Lugares que voc√™ quer visitar',
        tags: [],
        ownerId: userId,
        visibility: 'private',
        isAutoGenerated: true,
        canDelete: false,
        canRename: false,
        autoListType: 'want_to_visit',
        placesCount: 0,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        previewPlaces: [],
      },
      {
        id: 'auto-favorites',
        title: 'FAVORITOS',
        emoji: 'üçï',
        description: 'Lugares que voc√™ favoritou',
        tags: [],
        ownerId: userId,
        visibility: 'private',
        isAutoGenerated: true,
        canDelete: false,
        canRename: false,
        autoListType: 'favorites',
        placesCount: 0,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        previewPlaces: [],
      },
    ];
  }

  /**
   * Buscar todas as listas do usu√°rio usando Firestore diretamente
   */
  async getUserListsDirect(userId: string): Promise<List[]> {
    try {
      // Buscar todas as listas do usu√°rio
      const listsQuery = query(
        collection(firestore, 'lists'),
        where('ownerId', '==', userId),
        orderBy('createdAt', 'desc')
      );

      const listsSnapshot = await getDocs(listsQuery);
      const lists: List[] = [];

      for (const listDoc of listsSnapshot.docs) {
        const listData = listDoc.data();

        // Buscar primeiros 3 lugares para preview
        const previewPlacesQuery = query(
          collection(firestore, 'listPlaces'),
          where('listId', '==', listDoc.id),
          orderBy('order', 'asc'),
          limit(3)
        );

        const previewPlacesSnapshot = await getDocs(previewPlacesQuery);
        const places = [];

        for (const placeDoc of previewPlacesSnapshot.docs) {
          const placeData = placeDoc.data();
          // Buscar dados do lugar
          const placeRef = doc(firestore, 'places', placeData.placeId);
          const placeSnapshot = await getDoc(placeRef);

          if (placeSnapshot.exists()) {
            const placeFullData = placeSnapshot.data();
            places.push({
              id: placeSnapshot.id,
              name: placeFullData.googleData?.name || 'Lugar sem nome',
              category: placeFullData.categories?.[0] || 'restaurant',
            });
          }
        }

        // Criar o objeto List com os dados corretos
        const list: List = {
          id: listDoc.id,
          title: listData.title || '',
          emoji: listData.emoji || 'üìã',
          description: listData.description || '',
          tags: listData.tags || [],
          ownerId: listData.ownerId || userId,
          visibility: listData.visibility || 'private',
          isAutoGenerated: listData.isAutoGenerated || false,
          canDelete: listData.canDelete !== undefined ? listData.canDelete : true,
          canRename: listData.canRename !== undefined ? listData.canRename : true,
          autoListType: listData.autoListType || '',
          placesCount: listData.placesCount || places.length,
          createdAt: listData.createdAt?.toDate?.()?.toISOString() || new Date().toISOString(),
          updatedAt: listData.updatedAt?.toDate?.()?.toISOString() || new Date().toISOString(),
          previewPlaces: places,
        };

        lists.push(list);
      }

      return lists;
    } catch (error: any) {
      // Check for index requirement error and try fallback query
      if (error.code === 'failed-precondition' && error.message?.includes('index')) {
        return await this.getUserListsDirectFallback(userId);
      }

      throw {
        code: 'firestore_error',
        message: `Erro ao buscar listas: ${error.message}`,
      } as ListError;
    }
  }

  /**
   * Fallback query without orderBy when composite index is not available
   */
  private async getUserListsDirectFallback(userId: string): Promise<List[]> {
    try {
      // Simpler query without orderBy to avoid index requirement
      const listsQuery = query(collection(firestore, 'lists'), where('ownerId', '==', userId));

      const listsSnapshot = await getDocs(listsQuery);
      const lists: List[] = [];

      for (const listDoc of listsSnapshot.docs) {
        const listData = listDoc.data();

        // Buscar primeiros 3 lugares para preview
        const previewPlacesQuery = query(
          collection(firestore, 'listPlaces'),
          where('listId', '==', listDoc.id),
          limit(3)
        );

        const previewPlacesSnapshot = await getDocs(previewPlacesQuery);
        const places = [];

        for (const placeDoc of previewPlacesSnapshot.docs) {
          const placeData = placeDoc.data();
          // Buscar dados do lugar
          const placeRef = doc(firestore, 'places', placeData.placeId);
          const placeSnapshot = await getDoc(placeRef);

          if (placeSnapshot.exists()) {
            const placeFullData = placeSnapshot.data();
            places.push({
              id: placeSnapshot.id,
              name: placeFullData.googleData?.name || 'Lugar sem nome',
              category: placeFullData.categories?.[0] || 'restaurant',
            });
          }
        }

        // Criar o objeto List com os dados corretos
        const list: List = {
          id: listDoc.id,
          title: listData.title || '',
          emoji: listData.emoji || 'üìã',
          description: listData.description || '',
          tags: listData.tags || [],
          ownerId: listData.ownerId || userId,
          visibility: listData.visibility || 'private',
          isAutoGenerated: listData.isAutoGenerated || false,
          canDelete: listData.canDelete !== undefined ? listData.canDelete : true,
          canRename: listData.canRename !== undefined ? listData.canRename : true,
          autoListType: listData.autoListType || '',
          placesCount: listData.placesCount || places.length,
          createdAt: listData.createdAt?.toDate?.()?.toISOString() || new Date().toISOString(),
          updatedAt: listData.updatedAt?.toDate?.()?.toISOString() || new Date().toISOString(),
          previewPlaces: places,
        };

        lists.push(list);
      }

      // Sort manually by createdAt since we can't use orderBy
      lists.sort((a, b) => new Date(b.createdAt).getTime() - new Date(a.createdAt).getTime());

      return lists;
    } catch (error: any) {
      throw {
        code: 'firestore_error',
        message: `Erro ao buscar listas (fallback): ${error.message}`,
      } as ListError;
    }
  }

  /**
   * Buscar todas as listas do usu√°rio
   * Tenta primeiro usar Firestore diretamente, depois Cloud Functions, e por √∫ltimo mock data
   */
  async getUserLists(userId: string): Promise<List[]> {
    try {
      // Primeiro, tente usar Firestore diretamente
      return await this.getUserListsDirect(userId);
    } catch (firestoreError: any) {
      try {
        // Se Firestore direto falhar, tente Cloud Functions
        const getUserLists = httpsCallable(this.functions, 'getUserLists');
        const result = await getUserLists({ userId });

        const responseData = result.data as GetUserListsResponse;

        if (responseData && responseData.lists && Array.isArray(responseData.lists)) {
          return responseData.lists;
        } else {
          return [];
        }
      } catch (functionsError: any) {
        // Se Cloud Functions tamb√©m falhar e for "not-found", use mock data
        if (functionsError.code === 'not-found') {
          const mockLists = this.generateMockLists(userId);
          return mockLists;
        }

        // Para outros erros, propague o erro
        throw this.mapErrorToListError(functionsError);
      }
    }
  }

  /**
   * Criar uma nova lista usando Firestore diretamente
   */
  async createListDirect(listData: CreateListRequest, userId: string): Promise<List> {
    try {
      // Valida√ß√µes
      if (!listData.title || listData.title.trim().length < 2) {
        throw {
          code: 'invalid_data',
          message: 'T√≠tulo deve ter pelo menos 2 caracteres',
        } as ListError;
      }

      if (listData.title.length > 50) {
        throw {
          code: 'invalid_data',
          message: 'T√≠tulo deve ter no m√°ximo 50 caracteres',
        } as ListError;
      }

      // Verificar limites do usu√°rio (Free vs Premium)
      const userRef = doc(firestore, 'users', userId);
      const userDoc = await getDoc(userRef);

      if (userDoc.exists()) {
        const userData = userDoc.data();
        if (userData.accountType === 'free' && userData.listsCount >= 5) {
          throw {
            code: 'resource_exhausted',
            message: 'Limite de listas atingido. Upgrade para Premium para listas ilimitadas.',
          } as ListError;
        }
      }

      const now = new Date();
      const newListData = {
        title: listData.title.trim(),
        emoji: listData.emoji || 'üìç',
        description: listData.description?.trim() || '',
        ownerId: userId,
        visibility: listData.visibility || 'public',
        editors: [],

        // Configura√ß√µes
        isMonetized: false,
        price: 0,
        purchasedBy: [],

        // Metadados
        placesCount: 0,
        tags: listData.tags || [],
        category: 'general',

        // Listas autom√°ticas (sempre false para criadas manualmente)
        isSystemList: false,
        isAutoGenerated: false,
        canDelete: true,
        canRename: true,
        autoListType: '',

        // Timestamps
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp(),
      };

      // Adicionar o documento √† cole√ß√£o
      const docRef = await addDoc(collection(firestore, 'lists'), newListData);

      // Atualizar contador do usu√°rio
      if (userDoc.exists()) {
        await updateDoc(userRef, {
          listsCount: increment(1),
          updatedAt: serverTimestamp(),
        });
      }

      // Buscar o documento criado para retornar os dados atualizados
      const createdDoc = await getDoc(docRef);

      if (!createdDoc.exists()) {
        throw new Error('Failed to retrieve created list');
      }

      const createdData = createdDoc.data() as any;

      const newList: List = {
        id: docRef.id,
        title: createdData.title,
        emoji: createdData.emoji,
        description: createdData.description,
        tags: createdData.tags || [],
        ownerId: createdData.ownerId,
        visibility: createdData.visibility,
        isAutoGenerated: createdData.isAutoGenerated,
        canDelete: createdData.canDelete,
        canRename: createdData.canRename,
        autoListType: createdData.autoListType,
        placesCount: createdData.placesCount,
        createdAt: createdData.createdAt?.toDate?.()?.toISOString() || now.toISOString(),
        updatedAt: createdData.updatedAt?.toDate?.()?.toISOString() || now.toISOString(),
        previewPlaces: [],
      };

      return newList;
    } catch (error: any) {
      // Se o erro j√° √© um ListError, propague-o
      if (error.code) {
        throw error;
      }

      throw {
        code: 'firestore_error',
        message: `Erro ao criar lista: ${error.message}`,
      } as ListError;
    }
  }

  /**
   * Atualizar uma lista usando Firestore diretamente
   */
  async updateListDirect(updateData: UpdateListRequest, userId: string): Promise<List> {
    try {
      const { listId, ...updates } = updateData;

      // Verificar se lista existe e se usu√°rio √© o dono
      const listRef = doc(firestore, 'lists', listId);
      const listDoc = await getDoc(listRef);

      if (!listDoc.exists()) {
        throw {
          code: 'list_not_found',
          message: 'Lista n√£o encontrada',
        } as ListError;
      }

      const listData = listDoc.data();

      if (listData.ownerId !== userId) {
        throw {
          code: 'permission_denied',
          message: 'Apenas o dono pode editar a lista',
        } as ListError;
      }

      // Verificar se √© lista autom√°tica
      if (listData.isAutoGenerated && (updates.title || updates.emoji)) {
        throw {
          code: 'permission_denied',
          message: 'Listas autom√°ticas n√£o podem ser renomeadas',
        } as ListError;
      }

      // Validar campos
      const allowedFields = ['title', 'emoji', 'description', 'visibility', 'tags'];
      const updatePayload: any = {};

      for (const field of allowedFields) {
        if (updates[field as keyof typeof updates] !== undefined) {
          updatePayload[field] = updates[field as keyof typeof updates];
        }
      }

      if (updatePayload.title) {
        if (updatePayload.title.trim().length < 2 || updatePayload.title.length > 50) {
          throw {
            code: 'invalid_data',
            message: 'T√≠tulo deve ter entre 2 e 50 caracteres',
          } as ListError;
        }
        updatePayload.title = updatePayload.title.trim();
      }

      // Adicionar timestamp
      updatePayload.updatedAt = serverTimestamp();

      // Atualizar lista
      await updateDoc(listRef, updatePayload);

      // Buscar o documento atualizado
      const updatedDoc = await getDoc(listRef);
      const updatedData = updatedDoc.data() as any;

      const updatedList: List = {
        id: listId,
        title: updatedData.title,
        emoji: updatedData.emoji,
        description: updatedData.description,
        tags: updatedData.tags || [],
        ownerId: updatedData.ownerId,
        visibility: updatedData.visibility,
        isAutoGenerated: updatedData.isAutoGenerated,
        canDelete: updatedData.canDelete,
        canRename: updatedData.canRename,
        autoListType: updatedData.autoListType,
        placesCount: updatedData.placesCount,
        createdAt: updatedData.createdAt?.toDate?.()?.toISOString() || new Date().toISOString(),
        updatedAt: updatedData.updatedAt?.toDate?.()?.toISOString() || new Date().toISOString(),
        previewPlaces: listData.previewPlaces || [],
      };

      return updatedList;
    } catch (error: any) {
      // Se o erro j√° √© um ListError, propague-o
      if (error.code) {
        throw error;
      }

      throw {
        code: 'firestore_error',
        message: `Erro ao atualizar lista: ${error.message}`,
      } as ListError;
    }
  }

  /**
   * Criar uma nova lista
   * Tenta primeiro usar Firestore diretamente, depois Cloud Functions, e por √∫ltimo mock data
   */
  async createList(listData: CreateListRequest, userId?: string): Promise<List> {
    try {
      // Use o userId passado ou tente obter do auth atual
      const currentUserId = userId || 'current-user'; // Em produ√ß√£o, obter do contexto de auth

      // Primeiro, tente usar Firestore diretamente
      return await this.createListDirect(listData, currentUserId);
    } catch (firestoreError: any) {
      try {
        // Se Firestore direto falhar, tente Cloud Functions
        const createList = httpsCallable(this.functions, 'createList');
        const result = await createList(listData);

        const responseData = result.data as { list: List };

        if (responseData && responseData.list) {
          return responseData.list;
        } else {
          throw new Error('Invalid response format from createList function');
        }
      } catch (functionsError: any) {
        // Se Cloud Functions tamb√©m falhar e for "not-found", use mock data
        if (functionsError.code === 'not-found') {
          const mockList: List = {
            id: `mock-list-${Date.now()}`,
            title: listData.title,
            emoji: listData.emoji,
            description: listData.description,
            tags: listData.tags || [],
            ownerId: userId || 'current-user',
            visibility: listData.visibility,
            isAutoGenerated: false,
            canDelete: true,
            canRename: true,
            autoListType: '',
            placesCount: 0,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            previewPlaces: [],
          };
          return mockList;
        }

        throw this.mapErrorToListError(functionsError);
      }
    }
  }

  /**
   * Atualizar uma lista
   * Tenta primeiro usar Firestore diretamente, depois Cloud Functions, e por √∫ltimo mock data
   */
  async updateList(updateData: UpdateListRequest, userId: string): Promise<List> {
    try {
      // 1. Try direct Firestore access first
      return await this.updateListDirect(updateData, userId);
    } catch (error: any) {
      try {
        // 2. Fallback to Cloud Functions
        const updateList = httpsCallable(this.functions, 'updateList');
        const result = await updateList(updateData);

        const responseData = result.data as { list: List };

        if (responseData && responseData.list) {
          return responseData.list;
        } else {
          throw new Error('Invalid response format from updateList function');
        }
      } catch (functionsError: any) {
        // 3. Fallback to mock/simulation
        const mockUpdatedList: List = {
          id: updateData.listId,
          title: updateData.title || 'Lista Atualizada',
          emoji: updateData.emoji || 'üìù',
          description: updateData.description || '',
          tags: updateData.tags || [],
          ownerId: userId,
          visibility: updateData.visibility || 'private',
          isAutoGenerated: false,
          canDelete: true,
          canRename: true,
          autoListType: '',
          placesCount: 0,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          previewPlaces: [],
        };

        return mockUpdatedList;
      }
    }
  }

  /**
   * Deletar uma lista usando Firestore diretamente
   */
  async deleteListDirect(listId: string, userId: string): Promise<void> {
    try {
      // Verificar se lista existe e se usu√°rio √© o dono
      const listRef = doc(firestore, 'lists', listId);
      const listDoc = await getDoc(listRef);

      if (!listDoc.exists()) {
        throw {
          code: 'list_not_found',
          message: 'Lista n√£o encontrada',
        } as ListError;
      }

      const listData = listDoc.data();

      if (listData.ownerId !== userId) {
        throw {
          code: 'permission_denied',
          message: 'Apenas o dono pode deletar a lista',
        } as ListError;
      }

      if (!listData.canDelete) {
        throw {
          code: 'permission_denied',
          message: 'Esta lista n√£o pode ser deletada',
        } as ListError;
      }

      // Buscar todos os places da lista para deletar primeiro
      const listPlacesRef = collection(firestore, 'listPlaces');
      const listPlacesQuery = query(listPlacesRef, where('listId', '==', listId));
      const listPlacesSnapshot = await getDocs(listPlacesQuery);

      // Deletar todos os places da lista primeiro
      const deletePromises = listPlacesSnapshot.docs.map((placeDoc) => deleteDoc(placeDoc.ref));

      if (deletePromises.length > 0) {
        await Promise.all(deletePromises);
      }

      // Deletar a lista
      await deleteDoc(listRef);
    } catch (error: any) {
      // Se o erro j√° √© um ListError, propague-o
      if (error.code) {
        throw error;
      }

      throw {
        code: 'firestore_error',
        message: `Erro ao deletar lista: ${error.message}`,
      } as ListError;
    }
  }

  /**
   * Deletar uma lista
   * Tenta primeiro usar Firestore diretamente, depois Cloud Functions
   */
  async deleteList(listId: string): Promise<void> {
    try {
      // Obter usu√°rio atual
      const user = auth.currentUser;
      if (!user) {
        throw {
          code: 'not_authenticated',
          message: 'Usu√°rio deve estar logado para deletar listas',
        } as ListError;
      }

      // 1. Try direct Firestore access first
      await this.deleteListDirect(listId, user.uid);
    } catch (error: any) {
      try {
        // 2. Fallback to Cloud Functions
        const deleteListFunction = httpsCallable(this.functions, 'deleteList');
        const result = await deleteListFunction({ listId });
      } catch (functionsError: any) {
        throw this.mapErrorToListError(functionsError);
      }
    }
  }

  /**
   * Map Firebase function errors to ListError
   */
  private mapErrorToListError(error: any): ListError {
    if (error.code) {
      // Firebase function error
      switch (error.code) {
        case 'not-found':
          return {
            code: 'function_not_found',
            message: 'A fun√ß√£o getUserLists n√£o foi encontrada. Verifique se as Cloud Functions foram implantadas.',
          };
        case 'permission-denied':
          return {
            code: 'permission_denied',
            message: 'Voc√™ n√£o tem permiss√£o para realizar esta a√ß√£o',
          };
        case 'invalid-argument':
          return {
            code: 'invalid_data',
            message: 'Dados inv√°lidos fornecidos',
          };
        case 'unauthenticated':
          return {
            code: 'not_authenticated',
            message: 'Voc√™ precisa estar logado para realizar esta a√ß√£o',
          };
        case 'unavailable':
          return {
            code: 'service_unavailable',
            message: 'Servi√ßo temporariamente indispon√≠vel. Tente novamente em alguns momentos.',
          };
        case 'deadline-exceeded':
          return {
            code: 'timeout',
            message: 'Opera√ß√£o expirou. Verifique sua conex√£o e tente novamente.',
          };
        default:
          return {
            code: 'unknown_error',
            message: `Erro: ${error.code} - ${error.message || 'Erro desconhecido'}`,
          };
      }
    } else {
      // Network or other error
      return {
        code: 'network_error',
        message: 'Erro de rede. Verifique sua conex√£o e tente novamente',
      };
    }
  }

  /**
   * Adicionar lugar √† lista usando Firestore diretamente
   */
  async addPlaceToListDirect(addPlaceData: AddPlaceToListRequest, userId: string): Promise<ListPlace> {
    try {
      const { listId, placeId, personalNote = '', tags = [] } = addPlaceData;

      // Verificar se os par√¢metros s√£o v√°lidos
      if (!listId || !placeId || !userId) {
        throw {
          code: 'invalid_argument',
          message: 'listId, placeId e userId s√£o obrigat√≥rios',
        } as ListError;
      }

      // Verificar se lista existe e permiss√µes
      const listRef = doc(firestore, 'lists', listId);
      const listDoc = await getDoc(listRef);

      if (!listDoc.exists()) {
        throw {
          code: 'list_not_found',
          message: 'Lista n√£o encontrada',
        } as ListError;
      }

      const listData = listDoc.data();

      // Verificar permiss√µes (dono ou editor)
      const hasPermission = listData?.ownerId === userId;

      if (!hasPermission) {
        throw {
          code: 'permission_denied',
          message: 'Sem permiss√£o para adicionar lugares nesta lista',
        } as ListError;
      }

      // Verificar limites Free (15 lugares por lista)
      const userRef = doc(firestore, 'users', userId);
      const userDoc = await getDoc(userRef);
      const user = userDoc.exists() ? userDoc.data() : null;

      if (user?.accountType === 'free' && (listData?.placesCount || 0) >= 15) {
        throw {
          code: 'resource_exhausted',
          message: 'Limite de lugares por lista atingido (15). Upgrade para Premium para lugares ilimitados.',
        } as ListError;
      }

      // Verificar se lugar j√° existe na lista
      const listPlaceId = `${listId}_${placeId}`;
      const listPlaceRef = doc(firestore, 'listPlaces', listPlaceId);
      const existingListPlace = await getDoc(listPlaceRef);

      if (existingListPlace.exists()) {
        throw {
          code: 'already_exists',
          message: 'Este lugar j√° est√° na lista',
        } as ListError;
      }

      // Verificar se lugar existe na cole√ß√£o places
      const placeRef = doc(firestore, 'places', placeId);
      const placeDoc = await getDoc(placeRef);

      if (!placeDoc.exists()) {
        throw {
          code: 'place_not_found',
          message: 'Lugar n√£o encontrado',
        } as ListError;
      }

      // Buscar pr√≥xima ordem
      let nextOrder = 1;
      try {
        const lastPlaceQuery = query(
          collection(firestore, 'listPlaces'),
          where('listId', '==', listId),
          orderBy('order', 'desc'),
          limit(1)
        );
        const lastPlaceSnapshot = await getDocs(lastPlaceQuery);
        nextOrder = lastPlaceSnapshot.empty ? 1 : lastPlaceSnapshot.docs[0].data().order + 1;
      } catch (orderError: any) {
        nextOrder = Date.now(); // Use timestamp as fallback order
      }

      // Criar documento listPlace
      const listPlaceData = {
        listId: listId,
        placeId: placeId,
        addedBy: userId,
        addedAt: serverTimestamp(),
        order: nextOrder,
        personalNote: personalNote.trim(),
        tags: tags || [],
      };

      // Salvar o documento
      await setDoc(listPlaceRef, listPlaceData);

      // Atualizar contador da lista
      await updateDoc(listRef, {
        placesCount: increment(1),
        updatedAt: serverTimestamp(),
      });

      // Atualizar contador do usu√°rio
      if (userDoc.exists()) {
        await updateDoc(userRef, {
          placesCount: increment(1),
          updatedAt: serverTimestamp(),
        });
      }

      // Atualizar lugar (adicionar usu√°rio que adicionou)
      await updateDoc(placeRef, {
        addedBy: arrayUnion(userId),
        totalAdds: increment(1),
        updatedAt: serverTimestamp(),
      });

      const resultListPlace: ListPlace = {
        id: listPlaceId,
        listId: listId,
        placeId: placeId,
        addedBy: userId,
        addedAt: new Date().toISOString(),
        order: nextOrder,
        personalNote: personalNote.trim(),
        tags: tags || [],
      };

      return resultListPlace;
    } catch (error: any) {
      // Se o erro j√° √© um ListError, propague-o
      if (error.code) {
        throw error;
      }

      throw {
        code: 'firestore_error',
        message: `Erro ao adicionar lugar √† lista: ${error.message}`,
      } as ListError;
    }
  }

  /**
   * Adicionar lugar √† lista usando Cloud Function
   */
  async addPlaceToList(addPlaceData: AddPlaceToListRequest, userId: string): Promise<ListPlace> {
    try {
      // Para Google Places, precisamos buscar os dados primeiro
      if (addPlaceData.placeId.startsWith('ChIJ')) {
        // √â um Google Place ID, precisamos buscar os dados do Google Places

        // Buscar dados do Google Places API
        const placeDetailsResponse = await firebaseService.getPlaceDetails(addPlaceData.placeId);

        if (!placeDetailsResponse.success || !placeDetailsResponse.data) {
          throw new Error(placeDetailsResponse.error || 'Failed to get place details from Google');
        }

        const placeDetails = placeDetailsResponse.data;

        // Try direct Firestore method first (since Cloud Functions might not be available)
        try {
          return await this.addPlaceToListDirect(addPlaceData, userId);
        } catch (directError: any) {
          // If direct method fails, try Cloud Function as fallback
        }

        // Preparar dados para a cloud function no formato esperado
        const cloudFunctionData = {
          googlePlaceId: addPlaceData.placeId,
          googlePlaceData: {
            googlePlaceId: addPlaceData.placeId,
            name: placeDetails.place?.googleData?.name,
            address: placeDetails.place?.googleData?.address,
            rating: placeDetails.place?.googleData?.rating,
            types: placeDetails.place?.googleData?.types || [],
            geometry: placeDetails.place?.googleData?.coordinates
              ? {
                  location: {
                    lat: placeDetails.place.googleData.coordinates.lat,
                    lng: placeDetails.place.googleData.coordinates.lng,
                  },
                }
              : undefined,
            photos: placeDetails.place?.googleData?.photos || [],
            price_level: placeDetails.place?.googleData?.priceLevel,
            opening_hours: placeDetails.place?.googleData?.openingHours,
          },
          listId: addPlaceData.listId,
          personalNote: addPlaceData.personalNote || '',
          tags: addPlaceData.tags || [],
        };

        const addPlaceToListFn = httpsCallable(this.functions, 'addPlaceToList');
        const result = await addPlaceToListFn(cloudFunctionData);

        const responseData = result.data as any;

        if (responseData && responseData.success) {
          // A cloud function deve retornar o listPlace criado
          if (responseData.listPlace) {
            return responseData.listPlace;
          } else {
            // Se n√£o retornar o listPlace, criar um placeholder
            return {
              id: `${addPlaceData.listId}_${addPlaceData.placeId}`,
              listId: addPlaceData.listId,
              placeId: addPlaceData.placeId,
              addedBy: userId,
              addedAt: new Date().toISOString(),
              order: 1,
              personalNote: addPlaceData.personalNote || '',
              tags: addPlaceData.tags || [],
            };
          }
        } else {
          throw new Error(responseData?.error || 'Cloud function returned unsuccessful response');
        }
      } else {
        // Para lugares manuais, usar o m√©todo direto do Firestore
        return await this.addPlaceToListDirect(addPlaceData, userId);
      }
    } catch (error: any) {
      // Se for erro de cloud function, tentar fallback para Firestore direto
      if (error.code === 'not-found' || error.message?.includes('not-found')) {
        try {
          return await this.addPlaceToListDirect(addPlaceData, userId);
        } catch (firestoreError: any) {
          throw this.mapErrorToListError(firestoreError);
        }
      }

      throw this.mapErrorToListError(error);
    }
  }

  /**
   * Buscar lugares de uma lista usando Firestore diretamente
   */
  async getListPlacesDirect(listId: string): Promise<ListPlaceWithDetails[]> {
    try {
      // Buscar todos os listPlaces para esta lista
      const listPlacesQuery = query(
        collection(firestore, 'listPlaces'),
        where('listId', '==', listId),
        orderBy('order', 'asc')
      );

      const listPlacesSnapshot = await getDocs(listPlacesQuery);

      if (listPlacesSnapshot.empty) {
        return [];
      }

      // Extrair IDs dos places para busca em batch
      const listPlacesData = listPlacesSnapshot.docs.map((doc) => ({
        id: doc.id,
        ...doc.data(),
      })) as (ListPlace & { id: string })[];

      const placeIds = listPlacesData.map((lp) => lp.placeId);

      // Buscar places em batch (m√°ximo 10 por vez devido ao Firestore)
      const placesData = new Map();
      const batchSize = 10;

      for (let i = 0; i < placeIds.length; i += batchSize) {
        const batch = placeIds.slice(i, i + batchSize);

        const placesQuery = query(collection(firestore, 'places'), where('__name__', 'in', batch));

        const placesSnapshot = await getDocs(placesQuery);
        placesSnapshot.forEach((doc) => {
          placesData.set(doc.id, doc.data());
        });
      }

      // Montar resultado final
      const placesWithDetails: ListPlaceWithDetails[] = listPlacesData.map((listPlaceData) => {
        const placeData = placesData.get(listPlaceData.placeId);

        let placeDetails = undefined;
        if (placeData) {
          placeDetails = {
            id: listPlaceData.placeId,
            name: placeData.googleData?.name || placeData.name || 'Nome n√£o dispon√≠vel',
            address:
              placeData.googleData?.formatted_address || placeData.address?.formatted || 'Endere√ßo n√£o dispon√≠vel',
            coordinates: placeData.coordinates
              ? {
                  lat: placeData.coordinates.latitude || placeData.coordinates.lat,
                  lng: placeData.coordinates.longitude || placeData.coordinates.lng,
                }
              : { lat: 0, lng: 0 },
            rating: placeData.googleData?.rating || placeData.averageRatings?.overall,
            priceLevel: placeData.googleData?.priceLevel,
            photos: placeData.googleData?.photos || [],
            types: placeData.googleData?.types || [],
            phone: placeData.googleData?.phone || placeData.googleData?.formatted_phone_number,
            website: placeData.googleData?.website,
            category: placeData.category,
          };
        }

        return {
          id: listPlaceData.id,
          listId,
          placeId: listPlaceData.placeId,
          addedBy: listPlaceData.addedBy,
          addedAt:
            typeof listPlaceData.addedAt === 'string'
              ? listPlaceData.addedAt
              : (listPlaceData.addedAt as any)?.toDate?.()?.toISOString() || new Date().toISOString(),
          order: listPlaceData.order,
          personalNote: listPlaceData.personalNote,
          tags: listPlaceData.tags || [],
          place: placeDetails,
        };
      });

      return placesWithDetails;
    } catch (error: any) {
      throw {
        code: 'firestore_error',
        message: `Erro ao buscar lugares da lista: ${error.message}`,
      } as ListError;
    }
  }

  /**
   * Buscar lugares de uma lista
   * Tenta primeiro usar Firestore diretamente, depois Cloud Functions, e por √∫ltimo mock data
   */
  async getListPlaces(listId: string): Promise<ListPlaceWithDetails[]> {
    try {
      // 1. Try direct Firestore access first
      return await this.getListPlacesDirect(listId);
    } catch (error: any) {
      try {
        // 2. Fallback to Cloud Functions
        const getListPlaces = httpsCallable(this.functions, 'getListPlaces');
        const result = await getListPlaces({ listId });

        const responseData = result.data as GetListPlacesResponse;

        if (responseData && responseData.places) {
          return responseData.places;
        } else {
          throw new Error('Invalid response format from getListPlaces function');
        }
      } catch (functionsError: any) {
        // 3. Fallback to mock/simulation
        const mockPlaces: ListPlaceWithDetails[] = [
          {
            id: `${listId}_mock1`,
            listId: listId,
            placeId: 'mock_place_1',
            addedBy: 'mock_user',
            addedAt: new Date().toISOString(),
            order: 1,
            personalNote: 'Hamb√∫rguer incr√≠vel!',
            tags: ['hamburger', 'casual'],
            place: {
              id: 'mock_place_1',
              name: "MONTY'S GOOD BURGER",
              address: 'Rua das Palmeiras, 123 - Vila Madalena, S√£o Paulo',
              coordinates: { lat: -23.5505, lng: -46.6333 },
              rating: 4.7,
              priceLevel: 2,
              photos: ['https://via.placeholder.com/400x300/8B4513/FFFFFF?text=üçî'],
              types: ['restaurant', 'food', 'establishment'],
              phone: '(11) 98765-4321',
              website: 'https://montysburger.com',
            },
          },
          {
            id: `${listId}_mock2`,
            listId: listId,
            placeId: 'mock_place_2',
            addedBy: 'mock_user',
            addedAt: new Date().toISOString(),
            order: 2,
            personalNote: 'Ambiente perfeito para encontros',
            tags: ['romantic', 'dinner'],
            place: {
              id: 'mock_place_2',
              name: 'BURGER & CIA',
              address: 'Av. Paulista, 456 - Bela Vista, S√£o Paulo',
              coordinates: { lat: -23.5618, lng: -46.6565 },
              rating: 4.5,
              priceLevel: 2,
              photos: ['https://via.placeholder.com/400x300/228B22/FFFFFF?text=üçî'],
              types: ['restaurant', 'food', 'establishment'],
              phone: '(11) 91234-5678',
              website: 'https://burgerecia.com',
            },
          },
        ];

        return mockPlaces;
      }
    }
  }
  /**
   * Remover lugar da lista usando Cloud Function
   */
  async removePlace(listId: string, placeId: string) {
    try {
      const removePlaceFromList = httpsCallable(this.functions, 'removePlaceFromList');

      const result = await removePlaceFromList({
        listId,
        placeId,
      });

      return result.data;
    } catch (error: any) {
      const errorMessage = error.message || 'Erro desconhecido';
      return { success: false, error: errorMessage, data: [] };
    }
  }
}

export const listsService = new ListsService();
