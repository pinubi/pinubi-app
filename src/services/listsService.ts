import { firestore, functions } from '@/config/firebase';
import type {
  AddPlaceToListRequest,
  AddPlaceToListResponse,
  CreateListRequest,
  GetListPlacesResponse,
  GetUserListsResponse,
  List,
  ListError,
  ListPlace,
  ListPlaceWithDetails,
  UpdateListRequest
} from '@/types/lists';
import { addDoc, arrayUnion, collection, doc, getDoc, getDocs, increment, limit, orderBy, query, serverTimestamp, setDoc, updateDoc, where } from 'firebase/firestore';
import { httpsCallable } from 'firebase/functions';

class ListsService {
  private functions;
  private useMockData = false; // Set to true for testing without Cloud Functions

  constructor() {
    this.functions = functions;
  }

  /**
   * Generate mock data for testing
   */
  private generateMockLists(userId: string): List[] {
    return [
      {
        id: 'auto-want-to-visit',
        title: 'QUERO VISITAR',
        emoji: 'üçΩÔ∏è',
        description: 'Lugares que voc√™ quer visitar',
        ownerId: userId,
        visibility: 'private',
        isAutoGenerated: true,
        canDelete: false,
        canRename: false,
        autoListType: 'want_to_visit',
        placesCount: 0,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        previewPlaces: []
      },
      {
        id: 'auto-favorites',
        title: 'FAVORITOS',
        emoji: 'üçï',
        description: 'Lugares que voc√™ favoritou',
        ownerId: userId,
        visibility: 'private',
        isAutoGenerated: true,
        canDelete: false,
        canRename: false,
        autoListType: 'favorites',
        placesCount: 0,
        createdAt: new Date().toISOString(),
        updatedAt: new Date().toISOString(),
        previewPlaces: []
      }
    ];
  }

  /**
   * Buscar todas as listas do usu√°rio usando Firestore diretamente
   */
  async getUserListsDirect(userId: string): Promise<List[]> {
    try {
      console.log('üî• Fetching user lists directly from Firestore for user:', userId);
      
      // Buscar todas as listas do usu√°rio
      const listsQuery = query(
        collection(firestore, 'lists'),
        where('ownerId', '==', userId),
        orderBy('createdAt', 'desc')
      );
      
      const listsSnapshot = await getDocs(listsQuery);
      const lists: List[] = [];
      
      for (const listDoc of listsSnapshot.docs) {
        const listData = listDoc.data();
        
        // Buscar primeiros 3 lugares para preview
        const previewPlacesQuery = query(
          collection(firestore, 'listPlaces'),
          where('listId', '==', listDoc.id),
          orderBy('order', 'asc'),
          limit(3)
        );
        
        const previewPlacesSnapshot = await getDocs(previewPlacesQuery);
        const places = [];
        
        for (const placeDoc of previewPlacesSnapshot.docs) {
          const placeData = placeDoc.data();
          // Buscar dados do lugar
          const placeRef = doc(firestore, 'places', placeData.placeId);
          const placeSnapshot = await getDoc(placeRef);
          
          if (placeSnapshot.exists()) {
            const placeFullData = placeSnapshot.data();
            places.push({
              id: placeSnapshot.id,
              name: placeFullData.googleData?.name || 'Lugar sem nome',
              category: placeFullData.categories?.[0] || 'restaurant'
            });
          }
        }
        
        // Criar o objeto List com os dados corretos
        const list: List = {
          id: listDoc.id,
          title: listData.title || '',
          emoji: listData.emoji || 'üìã',
          description: listData.description || '',
          ownerId: listData.ownerId || userId,
          visibility: listData.visibility || 'private',
          isAutoGenerated: listData.isAutoGenerated || false,
          canDelete: listData.canDelete !== undefined ? listData.canDelete : true,
          canRename: listData.canRename !== undefined ? listData.canRename : true,
          autoListType: listData.autoListType || '',
          placesCount: listData.placesCount || places.length,
          createdAt: listData.createdAt?.toDate?.()?.toISOString() || new Date().toISOString(),
          updatedAt: listData.updatedAt?.toDate?.()?.toISOString() || new Date().toISOString(),
          previewPlaces: places
        };
        
        lists.push(list);
      }
      
      console.log('‚úÖ Successfully fetched lists from Firestore:', lists.length);
      return lists;
    } catch (error: any) {
      console.error('‚ùå Error fetching user lists from Firestore:', error);
      throw {
        code: 'firestore_error',
        message: `Erro ao buscar listas: ${error.message}`
      } as ListError;
    }
  }

  /**
   * Buscar todas as listas do usu√°rio
   * Tenta primeiro usar Firestore diretamente, depois Cloud Functions, e por √∫ltimo mock data
   */
  async getUserLists(userId: string): Promise<List[]> {
    try {
      // Primeiro, tente usar Firestore diretamente
      console.log('üî• Trying direct Firestore access first for user:', userId);
      return await this.getUserListsDirect(userId);
    } catch (firestoreError: any) {
      console.warn('‚ö†Ô∏è Direct Firestore access failed, trying Cloud Functions:', firestoreError.message);
      
      try {
        // Se Firestore direto falhar, tente Cloud Functions
        console.log('üî• Calling getUserLists Cloud Function for user:', userId);
        console.log('üî• Functions instance:', this.functions);
        console.log('üî• Firebase app config:', this.functions.app.options);
        
        const getUserLists = httpsCallable(this.functions, 'getUserLists');
        const result = await getUserLists({ userId });
        
        console.log('üî• getUserLists function result:', result);
        
        const responseData = result.data as GetUserListsResponse;
        
        if (responseData && responseData.lists && Array.isArray(responseData.lists)) {
          console.log('‚úÖ Successfully fetched lists via Cloud Functions:', responseData.lists.length);
          return responseData.lists;
        } else {
          console.log('‚ö†Ô∏è No lists found or invalid response format, returning empty array');
          console.log('‚ö†Ô∏è Response data structure:', responseData);
          return [];
        }
      } catch (functionsError: any) {
        console.error('‚ùå Error fetching user lists via Cloud Functions:', functionsError);
        console.error('‚ùå Functions error details:', {
          code: functionsError.code,
          message: functionsError.message,
          details: functionsError.details,
          stack: functionsError.stack
        });

        // Se Cloud Functions tamb√©m falhar e for "not-found", use mock data
        if (functionsError.code === 'not-found') {
          console.log('üöÄ Cloud Function not found, returning mock data for development');
          const mockLists = this.generateMockLists(userId);
          console.log('üöÄ Generated mock lists:', mockLists);
          return mockLists;
        }

        // Para outros erros, propague o erro
        throw this.mapErrorToListError(functionsError);
      }
    }
  }

  /**
   * Criar uma nova lista usando Firestore diretamente
   */
  async createListDirect(listData: CreateListRequest, userId: string): Promise<List> {
    try {
      console.log('üî• Creating list directly in Firestore with data:', listData);
      
      // Valida√ß√µes
      if (!listData.title || listData.title.trim().length < 2) {
        throw {
          code: 'invalid_data',
          message: 'T√≠tulo deve ter pelo menos 2 caracteres'
        } as ListError;
      }
      
      if (listData.title.length > 50) {
        throw {
          code: 'invalid_data',
          message: 'T√≠tulo deve ter no m√°ximo 50 caracteres'
        } as ListError;
      }

      // Verificar limites do usu√°rio (Free vs Premium)
      const userRef = doc(firestore, 'users', userId);
      const userDoc = await getDoc(userRef);
      
      if (userDoc.exists()) {
        const userData = userDoc.data();
        if (userData.accountType === 'free' && userData.listsCount >= 5) {
          throw {
            code: 'resource_exhausted',
            message: 'Limite de listas atingido. Upgrade para Premium para listas ilimitadas.'
          } as ListError;
        }
      }
      
      const now = new Date();
      const newListData = {
        title: listData.title.trim(),
        emoji: listData.emoji || 'üìç',
        description: listData.description?.trim() || '',
        ownerId: userId,
        visibility: listData.visibility || 'public',
        editors: [],
        
        // Configura√ß√µes
        isMonetized: false,
        price: 0,
        purchasedBy: [],
        
        // Metadados
        placesCount: 0,
        tags: listData.tags || [],
        category: "general",
        
        // Listas autom√°ticas (sempre false para criadas manualmente)
        isSystemList: false,
        isAutoGenerated: false,
        canDelete: true,
        canRename: true,
        autoListType: "",
        
        // Timestamps
        createdAt: serverTimestamp(),
        updatedAt: serverTimestamp()
      };

      // Adicionar o documento √† cole√ß√£o
      const docRef = await addDoc(collection(firestore, 'lists'), newListData);
      
      // Atualizar contador do usu√°rio
      if (userDoc.exists()) {
        await updateDoc(userRef, {
          listsCount: increment(1),
          updatedAt: serverTimestamp()
        });
      }
      
      // Buscar o documento criado para retornar os dados atualizados
      const createdDoc = await getDoc(docRef);
      
      if (!createdDoc.exists()) {
        throw new Error('Failed to retrieve created list');
      }
      
      const createdData = createdDoc.data() as any;
      
      const newList: List = {
        id: docRef.id,
        title: createdData.title,
        emoji: createdData.emoji,
        description: createdData.description,
        ownerId: createdData.ownerId,
        visibility: createdData.visibility,
        isAutoGenerated: createdData.isAutoGenerated,
        canDelete: createdData.canDelete,
        canRename: createdData.canRename,
        autoListType: createdData.autoListType,
        placesCount: createdData.placesCount,
        createdAt: createdData.createdAt?.toDate?.()?.toISOString() || now.toISOString(),
        updatedAt: createdData.updatedAt?.toDate?.()?.toISOString() || now.toISOString(),
        previewPlaces: []
      };
      
      console.log('‚úÖ Successfully created list in Firestore:', newList.id);
      return newList;
    } catch (error: any) {
      console.error('‚ùå Error creating list in Firestore:', error);
      
      // Se o erro j√° √© um ListError, propague-o
      if (error.code) {
        throw error;
      }
      
      throw {
        code: 'firestore_error',
        message: `Erro ao criar lista: ${error.message}`
      } as ListError;
    }
  }

  /**
   * Atualizar uma lista usando Firestore diretamente
   */
  async updateListDirect(updateData: UpdateListRequest, userId: string): Promise<List> {
    try {
      console.log('üî• Updating list directly in Firestore with data:', updateData);
      
      const { listId, ...updates } = updateData;
      
      // Verificar se lista existe e se usu√°rio √© o dono
      const listRef = doc(firestore, 'lists', listId);
      const listDoc = await getDoc(listRef);
      
      if (!listDoc.exists()) {
        throw {
          code: 'list_not_found',
          message: 'Lista n√£o encontrada'
        } as ListError;
      }
      
      const listData = listDoc.data();
      
      if (listData.ownerId !== userId) {
        throw {
          code: 'permission_denied',
          message: 'Apenas o dono pode editar a lista'
        } as ListError;
      }
      
      // Verificar se √© lista autom√°tica
      if (listData.isAutoGenerated && (updates.title || updates.emoji)) {
        throw {
          code: 'permission_denied',
          message: 'Listas autom√°ticas n√£o podem ser renomeadas'
        } as ListError;
      }
      
      // Validar campos
      const allowedFields = ['title', 'emoji', 'description', 'visibility', 'tags'];
      const updatePayload: any = {};
      
      for (const field of allowedFields) {
        if (updates[field as keyof typeof updates] !== undefined) {
          updatePayload[field] = updates[field as keyof typeof updates];
        }
      }
      
      if (updatePayload.title) {
        if (updatePayload.title.trim().length < 2 || updatePayload.title.length > 50) {
          throw {
            code: 'invalid_data',
            message: 'T√≠tulo deve ter entre 2 e 50 caracteres'
          } as ListError;
        }
        updatePayload.title = updatePayload.title.trim();
      }
      
      // Adicionar timestamp
      updatePayload.updatedAt = serverTimestamp();
      
      // Atualizar lista
      await updateDoc(listRef, updatePayload);
      
      // Buscar o documento atualizado
      const updatedDoc = await getDoc(listRef);
      const updatedData = updatedDoc.data() as any;
      
      const updatedList: List = {
        id: listId,
        title: updatedData.title,
        emoji: updatedData.emoji,
        description: updatedData.description,
        ownerId: updatedData.ownerId,
        visibility: updatedData.visibility,
        isAutoGenerated: updatedData.isAutoGenerated,
        canDelete: updatedData.canDelete,
        canRename: updatedData.canRename,
        autoListType: updatedData.autoListType,
        placesCount: updatedData.placesCount,
        createdAt: updatedData.createdAt?.toDate?.()?.toISOString() || new Date().toISOString(),
        updatedAt: updatedData.updatedAt?.toDate?.()?.toISOString() || new Date().toISOString(),
        previewPlaces: listData.previewPlaces || []
      };
      
      console.log('‚úÖ Successfully updated list in Firestore:', updatedList.id);
      return updatedList;
    } catch (error: any) {
      console.error('‚ùå Error updating list in Firestore:', error);
      
      // Se o erro j√° √© um ListError, propague-o
      if (error.code) {
        throw error;
      }
      
      throw {
        code: 'firestore_error',
        message: `Erro ao atualizar lista: ${error.message}`
      } as ListError;
    }
  }

  /**
   * Criar uma nova lista
   * Tenta primeiro usar Firestore diretamente, depois Cloud Functions, e por √∫ltimo mock data
   */
  async createList(listData: CreateListRequest, userId?: string): Promise<List> {
    try {
      // Use o userId passado ou tente obter do auth atual
      const currentUserId = userId || 'current-user'; // Em produ√ß√£o, obter do contexto de auth
      
      // Primeiro, tente usar Firestore diretamente
      console.log('üî• Trying direct Firestore creation first');
      return await this.createListDirect(listData, currentUserId);
    } catch (firestoreError: any) {
      console.warn('‚ö†Ô∏è Direct Firestore creation failed, trying Cloud Functions:', firestoreError.message);
      
      try {
        // Se Firestore direto falhar, tente Cloud Functions
        console.log('üî• Calling createList Cloud Function with data:', listData);
        
        const createList = httpsCallable(this.functions, 'createList');
        const result = await createList(listData);
        
        console.log('üî• createList function result:', result);
        
        const responseData = result.data as { list: List };
        
        if (responseData && responseData.list) {
          console.log('‚úÖ Successfully created list via Cloud Functions:', responseData.list.id);
          return responseData.list;
        } else {
          throw new Error('Invalid response format from createList function');
        }
      } catch (functionsError: any) {
        console.error('‚ùå Error creating list via Cloud Functions:', functionsError);

        // Se Cloud Functions tamb√©m falhar e for "not-found", use mock data
        if (functionsError.code === 'not-found') {
          console.log('üöÄ createList Cloud Function not found, creating mock list for development');
          const mockList: List = {
            id: `mock-list-${Date.now()}`,
            title: listData.title,
            emoji: listData.emoji,
            description: listData.description,
            ownerId: userId || 'current-user',
            visibility: listData.visibility,
            isAutoGenerated: false,
            canDelete: true,
            canRename: true,
            autoListType: '',
            placesCount: 0,
            createdAt: new Date().toISOString(),
            updatedAt: new Date().toISOString(),
            previewPlaces: []
          };
          console.log('üöÄ Generated mock list:', mockList);
          return mockList;
        }

        throw this.mapErrorToListError(functionsError);
      }
    }
  }

  /**
   * Atualizar uma lista
   * Tenta primeiro usar Firestore diretamente, depois Cloud Functions, e por √∫ltimo mock data
   */
  async updateList(updateData: UpdateListRequest, userId: string): Promise<List> {
    try {
      // 1. Try direct Firestore access first
      console.log('üî• Trying to update list with direct Firestore access');
      return await this.updateListDirect(updateData, userId);
    } catch (error: any) {
      console.warn('‚ùå Direct Firestore update failed, trying Cloud Functions:', error);
      
      try {
        // 2. Fallback to Cloud Functions
        console.log('üî• Calling updateList function with data:', updateData);
        
        const updateList = httpsCallable(this.functions, 'updateList');
        const result = await updateList(updateData);
        
        console.log('üî• updateList function result:', result);
        
        const responseData = result.data as { list: List };
        
        if (responseData && responseData.list) {
          console.log('‚úÖ Successfully updated list via Cloud Functions:', responseData.list.id);
          return responseData.list;
        } else {
          throw new Error('Invalid response format from updateList function');
        }
      } catch (functionsError: any) {
        console.warn('‚ùå Cloud Functions update failed, using mock data:', functionsError);
        
        // 3. Fallback to mock/simulation
        const mockUpdatedList: List = {
          id: updateData.listId,
          title: updateData.title || 'Lista Atualizada',
          emoji: updateData.emoji || 'üìù',
          description: updateData.description || '',
          ownerId: userId,
          visibility: updateData.visibility || 'private',
          isAutoGenerated: false,
          canDelete: true,
          canRename: true,
          autoListType: '',
          placesCount: 0,
          createdAt: new Date().toISOString(),
          updatedAt: new Date().toISOString(),
          previewPlaces: []
        };
        
        console.log('‚úÖ Using mock updated list:', mockUpdatedList);
        return mockUpdatedList;
      }
    }
  }

  /**
   * Deletar uma lista
   */
  async deleteList(listId: string): Promise<void> {
    try {
      console.log('üî• Calling deleteList function for list:', listId);
      
      const deleteList = httpsCallable(this.functions, 'deleteList');
      const result = await deleteList({ listId });
      
      console.log('üî• deleteList function result:', result);
      console.log('‚úÖ Successfully deleted list:', listId);
    } catch (error: any) {
      console.error('‚ùå Error deleting list:', error);
      throw this.mapErrorToListError(error);
    }
  }

  /**
   * Map Firebase function errors to ListError
   */
  private mapErrorToListError(error: any): ListError {
    console.log('üîç Mapping error:', { 
      code: error.code, 
      message: error.message,
      name: error.name,
      fullError: error 
    });

    if (error.code) {
      // Firebase function error
      switch (error.code) {
        case 'not-found':
          return {
            code: 'function_not_found',
            message: 'A fun√ß√£o getUserLists n√£o foi encontrada. Verifique se as Cloud Functions foram implantadas.'
          };
        case 'permission-denied':
          return {
            code: 'permission_denied',
            message: 'Voc√™ n√£o tem permiss√£o para realizar esta a√ß√£o'
          };
        case 'invalid-argument':
          return {
            code: 'invalid_data',
            message: 'Dados inv√°lidos fornecidos'
          };
        case 'unauthenticated':
          return {
            code: 'not_authenticated',
            message: 'Voc√™ precisa estar logado para realizar esta a√ß√£o'
          };
        case 'unavailable':
          return {
            code: 'service_unavailable',
            message: 'Servi√ßo temporariamente indispon√≠vel. Tente novamente em alguns momentos.'
          };
        case 'deadline-exceeded':
          return {
            code: 'timeout',
            message: 'Opera√ß√£o expirou. Verifique sua conex√£o e tente novamente.'
          };
        default:
          return {
            code: 'unknown_error',
            message: `Erro: ${error.code} - ${error.message || 'Erro desconhecido'}`
          };
      }
    } else {
      // Network or other error
      return {
        code: 'network_error',
        message: 'Erro de rede. Verifique sua conex√£o e tente novamente'
      };
    }
  }

  /**
   * Adicionar lugar √† lista usando Firestore diretamente
   */
  async addPlaceToListDirect(addPlaceData: AddPlaceToListRequest, userId: string): Promise<ListPlace> {
    try {
      console.log('üî• Adding place to list with direct Firestore access');
      console.log('üî• Request data:', { addPlaceData, userId });
      
      const { listId, placeId, personalNote = '', tags = [] } = addPlaceData;
      
      // Verificar se os par√¢metros s√£o v√°lidos
      if (!listId || !placeId || !userId) {
        throw {
          code: 'invalid_argument',
          message: 'listId, placeId e userId s√£o obrigat√≥rios'
        } as ListError;
      }
      
      // Verificar se lista existe e permiss√µes
      console.log('üî• Checking list exists:', listId);
      const listRef = doc(firestore, 'lists', listId);
      const listDoc = await getDoc(listRef);
      
      if (!listDoc.exists()) {
        console.error('‚ùå List not found:', listId);
        throw {
          code: 'list_not_found',
          message: 'Lista n√£o encontrada'
        } as ListError;
      }
      
      const listData = listDoc.data();
      console.log('üî• List data:', { ownerId: listData?.ownerId, placesCount: listData?.placesCount });
      
      // Verificar permiss√µes (dono ou editor)
      const hasPermission = listData?.ownerId === userId;
      console.log('üî• Permission check:', { hasPermission, listOwnerId: listData?.ownerId, currentUserId: userId });
      
      if (!hasPermission) {
        throw {
          code: 'permission_denied',
          message: 'Sem permiss√£o para adicionar lugares nesta lista'
        } as ListError;
      }
      
      // Verificar limites Free (15 lugares por lista)
      console.log('üî• Checking user limits:', userId);
      const userRef = doc(firestore, 'users', userId);
      const userDoc = await getDoc(userRef);
      const user = userDoc.exists() ? userDoc.data() : null;
      
      console.log('üî• User data:', { accountType: user?.accountType, exists: userDoc.exists() });
      
      if (user?.accountType === 'free' && (listData?.placesCount || 0) >= 15) {
        throw {
          code: 'resource_exhausted',
          message: 'Limite de lugares por lista atingido (15). Upgrade para Premium para lugares ilimitados.'
        } as ListError;
      }
      
      // Verificar se lugar j√° existe na lista
      const listPlaceId = `${listId}_${placeId}`;
      const listPlaceRef = doc(firestore, 'listPlaces', listPlaceId);
      const existingListPlace = await getDoc(listPlaceRef);
      
      if (existingListPlace.exists()) {
        throw {
          code: 'already_exists',
          message: 'Este lugar j√° est√° na lista'
        } as ListError;
      }
      
      // Verificar se lugar existe na cole√ß√£o places
      const placeRef = doc(firestore, 'places', placeId);
      const placeDoc = await getDoc(placeRef);
      
      if (!placeDoc.exists()) {
        throw {
          code: 'place_not_found',
          message: 'Lugar n√£o encontrado'
        } as ListError;
      }
      
      // Buscar pr√≥xima ordem
      const lastPlaceQuery = query(
        collection(firestore, 'listPlaces'),
        where('listId', '==', listId),
        orderBy('order', 'desc'),
        limit(1)
      );
      const lastPlaceSnapshot = await getDocs(lastPlaceQuery);
      const nextOrder = lastPlaceSnapshot.empty ? 1 : lastPlaceSnapshot.docs[0].data().order + 1;
      
      // Criar documento listPlace
      const listPlaceData = {
        listId: listId,
        placeId: placeId,
        addedBy: userId,
        addedAt: serverTimestamp(),
        order: nextOrder,
        personalNote: personalNote.trim(),
        tags: tags || []
      };
      
      console.log('üî• Creating listPlace document:', listPlaceData);
      
      // Salvar o documento
      await setDoc(listPlaceRef, listPlaceData);
      
      console.log('üî• Updating list counter...');
      // Atualizar contador da lista
      await updateDoc(listRef, {
        placesCount: increment(1),
        updatedAt: serverTimestamp()
      });
      
      // Atualizar contador do usu√°rio
      if (userDoc.exists()) {
        console.log('üî• Updating user counter...');
        await updateDoc(userRef, {
          placesCount: increment(1),
          updatedAt: serverTimestamp()
        });
      }
      
      console.log('üî• Updating place counter...');
      // Atualizar lugar (adicionar usu√°rio que adicionou)
      await updateDoc(placeRef, {
        addedBy: arrayUnion(userId),
        totalAdds: increment(1),
        updatedAt: serverTimestamp()
      });
      
      const resultListPlace: ListPlace = {
        id: listPlaceId,
        listId: listId,
        placeId: placeId,
        addedBy: userId,
        addedAt: new Date().toISOString(),
        order: nextOrder,
        personalNote: personalNote.trim(),
        tags: tags || []
      };
      
      console.log('‚úÖ Successfully added place to list in Firestore:', resultListPlace.id);
      return resultListPlace;
    } catch (error: any) {
      console.error('‚ùå Error adding place to list in Firestore:', error);
      
      // Se o erro j√° √© um ListError, propague-o
      if (error.code) {
        throw error;
      }
      
      throw {
        code: 'firestore_error',
        message: `Erro ao adicionar lugar √† lista: ${error.message}`
      } as ListError;
    }
  }

  /**
   * Adicionar lugar √† lista
   * Tenta primeiro usar Firestore diretamente, depois Cloud Functions, e por √∫ltimo mock data
   */
  async addPlaceToList(addPlaceData: AddPlaceToListRequest, userId: string): Promise<ListPlace> {
    try {
      // 1. Try direct Firestore access first
      console.log('üî• Trying to add place to list with direct Firestore access');
      return await this.addPlaceToListDirect(addPlaceData, userId);
    } catch (error: any) {
      console.warn('‚ùå Direct Firestore add place failed, trying Cloud Functions:', error);
      
      try {
        // 2. Fallback to Cloud Functions
        console.log('üî• Calling addPlaceToList function with data:', addPlaceData);
        
        const addPlaceToList = httpsCallable(this.functions, 'addPlaceToList');
        const result = await addPlaceToList({
          ...addPlaceData,
          userId
        });
        
        console.log('üî• addPlaceToList function result:', result);
        
        const responseData = result.data as AddPlaceToListResponse;
        
        if (responseData && responseData.listPlace) {
          console.log('‚úÖ Successfully added place to list via Cloud Functions:', responseData.listPlace.id);
          return responseData.listPlace;
        } else {
          throw new Error('Invalid response format from addPlaceToList function');
        }
      } catch (functionsError: any) {
        console.warn('‚ùå Cloud Functions add place failed, using mock data:', functionsError);
        
        // 3. Fallback to mock/simulation
        const mockListPlace: ListPlace = {
          id: `${addPlaceData.listId}_${addPlaceData.placeId}`,
          listId: addPlaceData.listId,
          placeId: addPlaceData.placeId,
          addedBy: userId,
          addedAt: new Date().toISOString(),
          order: 1,
          personalNote: addPlaceData.personalNote || '',
          tags: addPlaceData.tags || []
        };
        
        console.log('‚úÖ Using mock added place:', mockListPlace);
        return mockListPlace;
      }
    }
  }

  /**
   * Buscar lugares de uma lista usando Firestore diretamente
   */
  async getListPlacesDirect(listId: string): Promise<ListPlaceWithDetails[]> {
    try {
      console.log('üî• Fetching list places with direct Firestore access for list:', listId);
      
      // Buscar todos os listPlaces para esta lista
      const listPlacesQuery = query(
        collection(firestore, 'listPlaces'),
        where('listId', '==', listId),
        orderBy('order', 'asc')
      );
      
      const listPlacesSnapshot = await getDocs(listPlacesQuery);
      
      if (listPlacesSnapshot.empty) {
        console.log('‚úÖ No places found for list:', listId);
        return [];
      }
      
      // Buscar detalhes dos lugares
      const placesWithDetails: ListPlaceWithDetails[] = [];
      
      for (const listPlaceDoc of listPlacesSnapshot.docs) {
        const listPlaceData = listPlaceDoc.data();
        
        // Buscar dados do lugar
        const placeRef = doc(firestore, 'places', listPlaceData.placeId);
        const placeDoc = await getDoc(placeRef);
        
        let placeDetails = undefined;
        if (placeDoc.exists()) {
          const placeData = placeDoc.data();
          placeDetails = {
            id: placeData.id,
            name: placeData.googleData?.name || 'Nome n√£o dispon√≠vel',
            address: placeData.googleData?.address || 'Endere√ßo n√£o dispon√≠vel',
            coordinates: placeData.googleData?.coordinates || { lat: 0, lng: 0 },
            rating: placeData.googleData?.rating,
            priceLevel: placeData.googleData?.priceLevel,
            photos: placeData.googleData?.photos || [],
            types: placeData.googleData?.types || [],
            phone: placeData.googleData?.phone,
            website: placeData.googleData?.website
          };
        }
        
        const listPlaceWithDetails: ListPlaceWithDetails = {
          id: listPlaceDoc.id,
          listId: listPlaceData.listId,
          placeId: listPlaceData.placeId,
          addedBy: listPlaceData.addedBy,
          addedAt: listPlaceData.addedAt?.toDate?.()?.toISOString() || new Date().toISOString(),
          order: listPlaceData.order,
          personalNote: listPlaceData.personalNote,
          tags: listPlaceData.tags,
          place: placeDetails
        };
        
        placesWithDetails.push(listPlaceWithDetails);
      }
      
      console.log('‚úÖ Successfully fetched list places from Firestore:', placesWithDetails.length);
      return placesWithDetails;
    } catch (error: any) {
      console.error('‚ùå Error fetching list places from Firestore:', error);
      
      throw {
        code: 'firestore_error',
        message: `Erro ao buscar lugares da lista: ${error.message}`
      } as ListError;
    }
  }

  /**
   * Buscar lugares de uma lista
   * Tenta primeiro usar Firestore diretamente, depois Cloud Functions, e por √∫ltimo mock data
   */
  async getListPlaces(listId: string): Promise<ListPlaceWithDetails[]> {
    try {
      // 1. Try direct Firestore access first
      console.log('üî• Trying to fetch list places with direct Firestore access');
      return await this.getListPlacesDirect(listId);
    } catch (error: any) {
      console.warn('‚ùå Direct Firestore fetch list places failed, trying Cloud Functions:', error);
      
      try {
        // 2. Fallback to Cloud Functions
        console.log('üî• Calling getListPlaces function for list:', listId);
        
        const getListPlaces = httpsCallable(this.functions, 'getListPlaces');
        const result = await getListPlaces({ listId });
        
        console.log('üî• getListPlaces function result:', result);
        
        const responseData = result.data as GetListPlacesResponse;
        
        if (responseData && responseData.places) {
          console.log('‚úÖ Successfully fetched list places via Cloud Functions:', responseData.places.length);
          return responseData.places;
        } else {
          throw new Error('Invalid response format from getListPlaces function');
        }
      } catch (functionsError: any) {
        console.warn('‚ùå Cloud Functions fetch list places failed, using mock data:', functionsError);
        
        // 3. Fallback to mock/simulation
        const mockPlaces: ListPlaceWithDetails[] = [
          {
            id: `${listId}_mock1`,
            listId: listId,
            placeId: 'mock_place_1',
            addedBy: 'mock_user',
            addedAt: new Date().toISOString(),
            order: 1,
            personalNote: 'Hamb√∫rguer incr√≠vel!',
            tags: ['hamburger', 'casual'],
            place: {
              id: 'mock_place_1',
              name: "MONTY'S GOOD BURGER",
              address: 'Rua das Palmeiras, 123 - Vila Madalena, S√£o Paulo',
              coordinates: { lat: -23.5505, lng: -46.6333 },
              rating: 4.7,
              priceLevel: 2,
              photos: ['https://via.placeholder.com/400x300/8B4513/FFFFFF?text=üçî'],
              types: ['restaurant', 'food', 'establishment'],
              phone: '(11) 98765-4321',
              website: 'https://montysburger.com'
            }
          },
          {
            id: `${listId}_mock2`,
            listId: listId,
            placeId: 'mock_place_2',
            addedBy: 'mock_user',
            addedAt: new Date().toISOString(),
            order: 2,
            personalNote: 'Ambiente perfeito para encontros',
            tags: ['romantic', 'dinner'],
            place: {
              id: 'mock_place_2',
              name: 'BURGER & CIA',
              address: 'Av. Paulista, 456 - Bela Vista, S√£o Paulo',
              coordinates: { lat: -23.5618, lng: -46.6565 },
              rating: 4.5,
              priceLevel: 2,
              photos: ['https://via.placeholder.com/400x300/228B22/FFFFFF?text=üçî'],
              types: ['restaurant', 'food', 'establishment'],
              phone: '(11) 91234-5678',
              website: 'https://burgerecia.com'
            }
          }
        ];
        
        console.log('‚úÖ Using mock list places:', mockPlaces.length);
        return mockPlaces;
      }
    }
  }
}

export const listsService = new ListsService();
