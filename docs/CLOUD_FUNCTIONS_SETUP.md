# Cloud Functions Setup for Lists Integration

## Issue Diagnosis

The error `not-found` occurs because the `getUserLists` Cloud Function doesn't exist yet. This is expected since we've only implemented the frontend integration.

## Current Configuration

- **Development Mode**: Using Firebase Emulators
- **Functions Emulator**: Running on `127.0.0.1:5001`
- **Expected Functions**: `getUserLists`, `createList`, `updateList`, `deleteList`

## Temporary Solution

I've updated the `ListsService` to provide mock data when Cloud Functions are not found. This allows the app to function during development while the backend is being implemented.

### Mock Data Features:
- ✅ Auto-generated "Quero Visitar" list
- ✅ Auto-generated "Favoritos" list  
- ✅ Mock list creation functionality
- ✅ Proper data structure matching the schema

## Required Cloud Functions

To complete the integration, implement these Cloud Functions:

### 1. getUserLists
```javascript
exports.getUserLists = functions.https.onCall(async (data, context) => {
  const { userId } = data;
  
  // Validate authentication
  if (!context.auth) {
    throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
  }
  
  try {
    const listsSnapshot = await admin.firestore()
      .collection('lists')
      .where('ownerId', '==', userId)
      .orderBy('createdAt', 'desc')
      .get();

    const lists = [];
    
    for (const doc of listsSnapshot.docs) {
      const listData = doc.data();
      
      // Buscar primeiros 3 lugares para preview
      const previewPlaces = await admin.firestore()
        .collection('listPlaces')
        .where('listId', '==', doc.id)
        .orderBy('order', 'asc')
        .limit(3)
        .get();
      
      const places = [];
      for (const placeDoc of previewPlaces.docs) {
        const placeData = placeDoc.data();
        const place = await admin.firestore()
          .collection('places')
          .doc(placeData.placeId)
          .get();
        if (place.exists) {
          places.push({
            id: place.id,
            name: place.data().googleData?.name || 'Lugar sem nome',
            category: place.data().categories?.[0] || 'restaurant'
          });
        }
      }
      
      lists.push({
        id: doc.id,
        ...listData,
        previewPlaces: places
      });
    }
    
    return { lists };
  } catch (error) {
    throw new functions.https.HttpsError('internal', `Erro ao buscar listas: ${error.message}`);
  }
});
```

### 2. createList
```javascript
exports.createList = functions.https.onCall(async (data, context) => {
  if (!context.auth) {
    throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
  }

  const { title, emoji, description, visibility, tags = [] } = data;
  const userId = context.auth.uid;

  try {
    const listData = {
      title,
      emoji,
      description,
      ownerId: userId,
      visibility,
      isAutoGenerated: false,
      canDelete: true,
      canRename: true,
      autoListType: '',
      placesCount: 0,
      createdAt: admin.firestore.FieldValue.serverTimestamp(),
      updatedAt: admin.firestore.FieldValue.serverTimestamp(),
      tags
    };

    const docRef = await admin.firestore().collection('lists').add(listData);
    const createdDoc = await docRef.get();

    return { 
      list: { 
        id: docRef.id, 
        ...createdDoc.data(),
        previewPlaces: []
      } 
    };
  } catch (error) {
    throw new functions.https.HttpsError('internal', `Erro ao criar lista: ${error.message}`);
  }
});
```

### 3. updateList
```javascript
exports.updateList = functions.https.onCall(async (data, context) => {
  if (!context.auth) {
    throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
  }

  const { listId, ...updateData } = data;
  const userId = context.auth.uid;

  try {
    const listRef = admin.firestore().collection('lists').doc(listId);
    const listDoc = await listRef.get();

    if (!listDoc.exists) {
      throw new functions.https.HttpsError('not-found', 'Lista não encontrada');
    }

    const listData = listDoc.data();
    if (listData.ownerId !== userId) {
      throw new functions.https.HttpsError('permission-denied', 'Você não tem permissão para editar esta lista');
    }

    await listRef.update({
      ...updateData,
      updatedAt: admin.firestore.FieldValue.serverTimestamp()
    });

    const updatedDoc = await listRef.get();
    return { 
      list: { 
        id: listId, 
        ...updatedDoc.data() 
      } 
    };
  } catch (error) {
    throw new functions.https.HttpsError('internal', `Erro ao atualizar lista: ${error.message}`);
  }
});
```

### 4. deleteList
```javascript
exports.deleteList = functions.https.onCall(async (data, context) => {
  if (!context.auth) {
    throw new functions.https.HttpsError('unauthenticated', 'User must be authenticated');
  }

  const { listId } = data;
  const userId = context.auth.uid;

  try {
    const listRef = admin.firestore().collection('lists').doc(listId);
    const listDoc = await listRef.get();

    if (!listDoc.exists) {
      throw new functions.https.HttpsError('not-found', 'Lista não encontrada');
    }

    const listData = listDoc.data();
    if (listData.ownerId !== userId) {
      throw new functions.https.HttpsError('permission-denied', 'Você não tem permissão para deletar esta lista');
    }

    if (!listData.canDelete) {
      throw new functions.https.HttpsError('permission-denied', 'Esta lista não pode ser deletada');
    }

    // Delete list places first
    const listPlacesSnapshot = await admin.firestore()
      .collection('listPlaces')
      .where('listId', '==', listId)
      .get();

    const batch = admin.firestore().batch();
    listPlacesSnapshot.docs.forEach(doc => {
      batch.delete(doc.ref);
    });
    batch.delete(listRef);

    await batch.commit();
    return {};
  } catch (error) {
    throw new functions.https.HttpsError('internal', `Erro ao deletar lista: ${error.message}`);
  }
});
```

## Testing with Mock Data

Until the Cloud Functions are implemented, the app will use mock data:

1. **Auto-generated lists**: "Quero Visitar" and "Favoritos" with 0 places
2. **Create functionality**: Creates mock lists that persist in the local state
3. **Error handling**: Graceful fallback to mock data

## Next Steps

1. **Deploy Cloud Functions**: Implement and deploy the functions above
2. **Test with Real Data**: Once deployed, the app will automatically switch to real data
3. **Remove Mock Fallback**: After confirming everything works, remove the mock data fallback

## Development Notes

The frontend is fully implemented and ready. The mock data fallback ensures a smooth development experience while the backend is being completed.
